{
  "name": "PHP5 Authentication",
  "tagline": "",
  "body": "#PHP5 PASSWORD ENCRYPTION TUTORIAL\r\n\r\n##Why hashing?\r\nIf you ever consider publishing your database online, you should be aware that a time will come when it will be compromised in a way. When a time like that comes, the last thing anyone wants is all the data stored in database to be clearly visible. You should aim to hash at least passwords if not all of the personal data (this may have an impact on performance and loading speed). \r\nBy applying a hashing algorithm to your data before storing it into a database, it is practically impossible for them to be compromised even if the database is hacked. At the same time this data can be recovered by you as easily as it was secured. However, this only secures data from being accessed through database and not in other places in your code where you might be using it to perform various actions. \r\nEncrypting passwords using MD5() or similar algorithms may seem like a good idea due to their speed and efficiency - and to some extent it works great, but the process is reversible and can be “brute-forced” very easily; therefore, you should avoid securing sensitive data through these kinds of algorithms.\r\nTwo rules of thumb you should always follow:\r\n*\tDON’T save passwords as plain text\r\n*\tDON’T try to invent your own password security (unless you are a security expert)\r\n\r\n##Hashing using PHP’s crypt() function\r\nBcrypt is a popular way of hashing and is cryptographically very strong. To make passwords harder to break, have them follow the following constrains:\r\n*\tUse a different salt for each password\r\n*\tLimit the number of failed login attempts\r\n*\tMake the user includes special characters\r\n*\tRequire passwords of a greater length (e.g. >= 7 char)\r\n\r\nFollowing these principles makes any attacks extremely unlikely to obtain sensitive data\r\nSalting is a process of appending characters to a sequence of characters (e.g. a string “iLovePHP” would become “iLovePHP12jnt3v23” after salting it with “12jnt3v23”. The new string is what we call a salt.\r\n\r\n1.)\tFirst, we need to hash the user’s password obtained from the server\r\n\r\n\r\n\r\n    <?php\r\n    $username = ‘user’;\r\n    /*\r\n    Obviously password will not appear in your code like this, but it is shown here for the sake of clarity\r\n    */\r\n    $password = ‘iloveapples!’;  \r\n        \r\n    //Create a random salt – the “randomer” the better\r\n    $salt = strstr(base64_encode(mcrypt_create_iv(16, MCRYPT_DEV_URANDOM)), ‘+’, ‘.’);\r\n    \r\n    /*\r\n    Now we prefix hash information, which will let php know how to verify the password. \r\n    The first parameter describes the algorithm we are using, more can be found on php5’s crypt() function tutorial\r\n    The second parameter represents the option for the hashing algorithm – basically means the level of security\r\n    */\r\n    \r\n    $salt = sprint(“$2a$%02d$”, 10).$salt;\r\n    \r\n    //All we need to do now is use the crypt function and the password is hashed\r\n    $hash = crypt($password, $salt);\r\n    ?> \r\n\r\n\r\n\r\n\r\n*IMPORTANT!*\r\nAs mentioned earlier, hashing is irreversible; therefore in order to verify the password, you must store the hash and the salt you have used with the password in the same row in your database. If you don’t, you will not be able to validate it. \r\n\r\nThis wasn’t too bad was it? We now have a very secure password that can be stored in our database. Hint: you store $has in your database as the user’s password\r\nBut how do we validate the password?! \r\n\r\n2.)\tIn the second example we will take a look at how we validate a hashed password. What we need to do first is obtain the password, it’s salt, and hash from your database (tutorial on how to connect with databases can be found here).  Then you need to salt the password again and use the same hashing function. If the result matches, the password is validated.\r\n\r\n\r\n    //Here goes your code for accessing your database and obtaining user’s info\r\n    $username = ‘user’;\r\n\r\n    //Again, password is displayed here just for the sake of clarity\r\n    $password = ‘iloveapples!’;\r\n    \r\n    //Obtain hash associated with the user\r\n    $hash = $db -> prepare(‘SELECT hash FROM users WHERE username = :username LIMIT 1’);\r\n    \r\n    //Bind it to the password\r\n    $temp -> bindParam(‘:username’, $username);\r\n    \r\n    $temp->execute();\r\n    \r\n    //Obtain anonymous object\r\n    $user = $temp -> fetch(PDO::FETCH_OBJ);\r\n    \r\n    //Hash again and see if the hashes match; if they do the password is valid!\r\n    if( hash_equals($user -> hash, crypt($password, $user->hash)) ){\r\n     \t//Password is correct, yay!\r\n    }\r\n\r\n\r\n\r\n\r\n\r\nAs you can see PHP enables us to make a bulletproof vest for our users’ passwords that is very easy to implement. Following the guidelines of this tutorial should help you with anxiety of losing sensitive data. However, hashing DOES NOT prevent from attacks from happening, nor does it prevent breaches into your database; but that is another battle for another day. \r\n\r\n\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}